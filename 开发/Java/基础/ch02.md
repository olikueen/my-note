[toc]
# 1 方法
## 1.1 语句块
```
定义：
        使用花括号 {} 括起来的的任意数量的Java语句；

作用：
        决定局部变量的作用域；

注意：
        一个块，可以被嵌套在另个块中；
        但是不能在两个嵌套的块中声明同名的变量；
```
## 1.2 方法
```
格式：
        [修饰符1 修饰符2 ...] 返回值类型 方法名(形式参数列表) {
            Java语句；
            ...
        }
```

## 1.3 方法重载
```
定义：
        在一个类中定义多个方法名相同，但参数不同的方法；
        调用时，根据不同的参数自动调用对应的方法；

构成条件：
        1. 形参类型、形参个数、形参顺序不同，构成重载；
        2. 只有返回值不同，不构成重载；
        3. 只有形参名称不同，不构成重载；
```

## 1.4 递归调用
```
注意：
        1. 递归的优点是程序结构简单；
        2. 但是递归调用会占用大量的系统堆栈，努力村耗用多；
        3. 在递归调用层次多时，程序执行速度比普通循环慢得多；
在要求高性能的情况下，尽量避免使用递归；
```


# 2 class 类
```
每一个源文件，有且只有一个 public class，并且类名和文件名保持一致；
格式：
        [修饰符] class 类名 {
            属性1的类型 属性1;
            属性2的类型 属性2;
            ...
            方法1;
            方法2;
            ...
        }

#--------------------------------------------------------------------
对象：
        创建对象：
                类名 对象名 = new 类名();
        使用对象：
                对象名.属性
                对象名.方法

#--------------------------------------------------------------------


```
## 2.1 属性
```
属性，field，或者叫成员变量、实例变量；

属性：
        在类中定义，用来描述对象；
        作用域在整个类内部都可见；
        java会给属性自动赋予初始值；

局部变量
        在类的方法中定义，在方法中临时保存数据；
        作用域仅限于方法内；
        java不会给局部变量赋予初始值；
        在同一个方法中，不允许有同名局部变量；在不同方法中，可以有同名局部变量；
        成员变量和局部变量同名时，局部变量有更高的优先级；
```
## 2.2 方法
### 2.2.1 构造方法(构造器)
```
构造器，也叫构造方法(constructor)，用于对象的初始化；

格式：
        [修饰符(public)] 类名(形参列表) {
            ...;
        }

注意：
        1. 使用 new关键字 调用；
        2. 构造器不能使用return来返回值，构造器的返回值的类型是类本身；
        3. 如果没有定义构造器，编译器会自动定义一个无参构造函数；已经定义了构造器，编译器则不会自动添加；
        4. 构造器的方法名必须和类名一致；

# --------------------------------------------------------------------
构造方法重载：
        和普通方法重载一致；

        注意：
                如果方法构造中，形参名和属性名 相同时，需要使用this关键字区分属性和形参；
                this.id 表示属性id，id 表示形参id；
```
## 2.3 关键字
### 2.3.1 static关键字
```
定义：
        Java中被static修饰的 成员 被称为 静态成员 或 类成员；
        它属于整个类，而不是被某个对象所拥有；
        静态成员可以直接使用类名进行访问(推荐)，也可以使用对象名进行访问；

static可以修饰变量、方法和代码块；

调用静态方法：
        注意：
                1. 静态方法中可以直接调用同类中的静态成员。但不能调用非静态成员；如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量；
                2. 在普通成员方法中，则可以直接访问同类的非静态变量和静态变量；
                3. 静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法；

静态初始化块：
        Java中可以使用初始化块，进行数据赋值；
        在类的声明中，可以包含多个初始化块，当创建类的实例是们就会依次执行这些代码块；
        使用static修饰初始化块，就称为静态初始化块；

        注意：
                静态初始化块，只在类加载时执行，且只会执行一次（如果创建两个对象，那么只有第一个对象会执行静态初始化块）；
                同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量；
```
# 3 封装
## 3.1 getter/setter方法
```
定义：
        修改属性的可见性
        创建getter/setter方法，用于读写属性的值；
        在getter/setter方法中增加属性控制语句，对属性值的合法性进行判断；
```
## 3.2 Java的包
```
作用：
        管理Java文件；
        解决同名文件冲突；
        使用包区分相同作用的类；
定义包：
        package 包名
        备注：
                必须放在Java远程的第一行；
                包名间使用 "."号隔开；
                example: com.lance.TestClass

使用：
        1. 通过import关键字，可以在某个文件中使用其他文件的类；
                import com.lance.music.MyClass
        2. 包的命名规范是全小写字母全拼；
        3. 使用的时候可以加载某个包下的所有文件，或者某个具体子包下的所有文件；
                import com.lance.*
                import com.lance.music.*
```
## 3.3 访问修饰符
| 访问修饰符    | 本类 | 同包 | 子类 | 其他 |
| :------------ | ---- | ---- | ---- | ---- |
| private       | √    |      |      |      |
| default(默认) | √    | √    |      |      |
| protected     | √    | √    | √    |      |
| public        | √    | √    | √    | √    |

### 3.4 this关键字
```
定义：
        代表当前对象；
                this.属性 操作当前对象的属性；
                this.方法 调用当前对象的方法；
        封装对象的属性的时候，经常使用this关键字；
```
### 3.5 内部类
```
定义：
        定义在另外一个类里面的类；
作用：
        内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类；
        内部类的方法可以直接访问外部类的所有数据，包括私有的数据；
        内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便；
分类：
        成员内部类；
        静态内部类
        方法内部类
        匿名内部类

举例：
        public class HelloWorld {       //外部类HelloWorld
            public class Inner {        // 内部类Inner，类Inner在类HelloWorld的内部
        		public void show() {      // 内部类的方法
        			System.out.println("welcome to imooc!");
        		}
        	}

        	public static void main(String[] args) {
        		HelloWorld hello = new HelloWorld();      // 创建外部类对象
        		Inner i = hello.new Inner();              // 创建内部类对象

        		i.show();             // 调用内部类对象的方法
        	}
        }
```

#### 3.5.1 成员内部类
```
定义：
        成员内部类，也称为普通内部类；

用法：
        1. Inner类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如public 、protected 、private等；
        2. Inner 类中定义的 test() 方法可以直接访问 Outer 类中的数据，而不受Outer中的访问控制符的影响；
        3. 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即："内部类 对象名 = 外部类对象.new 内部类( ); "；
        4. 编译包含内部类的程序会生成两个.class文件；内部类的.class文件是：外部类名$内部类名.class；

注意：
        1. 外部类不能直接访问内部类的属性和方法；需要先创建内部类的对象才能访问其属性和方法；
        2. 如果外部类和内部类具有相同的成员变量或方法，内部类默认先访问自己的成员变量或方法，如果要使用外部类的成员变量，可以使用this关键字；(外部类名.this.属性)
```

#### 3.5.2 静态内部类
```
定义：
        使用static修饰的内部类；

用法：
        1. 静态内部类，不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问；
        2. 如果外部类的静态成员与内部类的成员名称相同，可以通过 "类名.静态成员" 访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过 "成员名" 直接调用外部类的静态成员；
        3. 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 "内部类 对象名 = new 内部类();"；
```

#### 3.5.3 方法内部类
```
定义：
        内部定义在外部类的方法中；

注意：
        方法内部类只有在方法内部可以使用；
        方法内部类，不可以使用访问控制符和static修饰；

举例：
        package com.lance;
        public class FOuter {
            public void show() {
                final int a = 25;
                int b = 10;
                class FInner {
                    int c = 2;
                    public void print() {
                        System.out.println("访问外部类中的常量a: " + a);
                        System.out.println("访问外部类中的变量b: " + b);
                        System.out.println("访问内部类中的变量c: " + c);
                    }
                }
                FInner fi = new FInner();
                fi.print();
            }
            public static void main(String[] args) {
                FOuter fo = new FOuter();
                fo.show();
            }
        }

问题：
        方法内部类如何访问外部类中的同名变量？
```

#### 3.5.4 匿名内部类
```
定义：
        没有名字的内部类，多用于关注实现而不关注实现类的名称；
        
语法格式：
        常和接口配合使用；
        Interface i = new Interface() {
            public void method() {  // 实现接口中定义的方法
                System.out.println("匿名内部类实现接口的方式");
            }
        }
        i.method();
        
        或者这样写：
        new Interface() {
            public void method() {  // 实现接口中定义的方法
                System.out.println("匿名内部类实现接口的方式");
            }
        }.method();

```

# 4 继承
```
注意：
        子类不能继承父类 private 修饰的成员变量个方法；
        
语法：
        class 子类 extends 父类 {
            ...
        }

```
## 4.1 方法重写
```
定义：
        在子类中重写父类的方法；
        方法名、返回值、参数类型及个数与继承父类的方法相同；
        调用时，优先调用子类方法；
```

## 4.2 final 关键字
```
定义：
        final 可以修饰类、方法、属性和变量；
        
用法：
        final修饰类，该类不允许被继承；
        final修饰方法，该方法不允许被重写；
        final修饰属性，该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）；
        
```
## 4.3 super 关键字
```
定义：
        在对象的内部使用，可以代表父类对象；

用法：
        访问父类的属性： super.父类属性
        访问父类的方法： super.父类方法()
        
注意：
        子类的构造过程当中必须代用其父类的构造方法；
        如果子类的构造方法中没有显示调用父类的构造方法，则系统默认调用父类的无参的构造方法；
        如果显示的调用构造方法，必须在子类的构造方法的一行；
        如果子类构造方法中既没有显示调用父类的构造方法，而父类又没有无参的构造方法，则编译出错；

```
## 4.4 Object类
```
Object类时所有类的父类，如果一个类没有使用extends关键字明确标识继承另外一个类，那么这个类默认继承Object类；

```
### 4.4.1 toString()方法
```
默认调用toString()方法的时候返回对象的哈希code码（对象内存地址字符串）；
可以通过重写toString()方法表示出对象的属性；
```
### 4.4.2 equals()方法
```
比较的是对象的引用是否指向同一块内存地址；
```

# 5 多态
## 5.1 引用多态
```
定义：
        父类的引用可以指向本类的对象；
        父类的引用可以指向子类的对象；
        
用法：
        父类名 父类对象 = new 父类();
        父类名 父类对象 = new 子类();

```
## 5.2 方法多态
```
定义：
        创建本类对象时，调用的方法为本类方法；
        创建子类对象时，调用的方法为子类重写的方法或者继承方法；

```
## 5.3 引用类型转换
```
分类：
        向上类型转换（隐式/自动类型转换），是小类型到大类型的转换；
        向下类型转换（强制类型转换），是大类型到小类型；
        
举例：
        Dog dog = new Dog();
        Animal animal = dog;
        Dog dog2 = (Dog)animal;
        if (animal instanceof Cat){
            Cat cat = (Cat)animal;    
        } else {
            System.oyt.println("不能进行类型转换")；
        }

```
### 5.3.1 instanceof 关键字
```
定义：
        用来在运行时指出对象是否是特定类的一个实例；
        
用法：
        object instanceof Class
        
        animal instanceof Cat
                animal对象是否是Cat的一个实例；
```
## 5.4 抽象类
```
定义：
        类前使用abstract关键字修饰，就是抽象类；

作用：
        限制了子类中必须实现的某些方法，但不关注实现细节；
        
规则：
        1. 使用abstract关键字定义抽象类；
        2. abstrace定义的抽象方法，只有声明，不需要实现；
        3. 包含抽象方法的类时抽象类；
        4. 抽象类中可以包含普通方法，也可以没有抽象方法；
        5. 抽象类不能直接创建对象，只能被子类继承；
```

## 5.5 接口
```
定义：
        接口可以理解为一种特殊的类，有全局常量和公共的抽象方法组成；

语法：
        使用 interface 定义接口；
        [修饰符] interface 接口名 [extends 父接口1， 父接口2...] {
            零到多个常量定义...
            零到多个抽象方法定义...
        }

注意：
        接口就是用来被继承、被实现的，修饰符一般建议使用 public；
        不能使用 private 和 protected 修饰接口；
        
        接口中的属性只能是常量，即使定义时不添加public static final修饰符，系统也会自动加上；
        接口中的方法只能是抽象方法，系统会自动加上public abstract修饰符；
        
使用：
        一个类可以实现一个或多个接口，实现接口使用 implements 关键字；
        [修饰符] class 类名 extends 父类 implements 接口1, 接口2... {
            类主体
            // 如果继承了抽象类，则要实现抽象方法；
            // 实现接口中的抽象方法；
            // 如果要继承父类，
        }
```

# 6 UML 简介
```
UML概念：
        Unified Modeling Language (UML) 又称统一建模语言或标准建模语言；
        是一个支持模型化和软件系统开发的图形化语言；
        为软件开发的所有阶段提供模型化和可视化支持；
        
UML图示：
        UML2.2中一共定义了14种图示(diagrams)；
        
常用UML图：
        用例图(The Use Case Diagram)，能够以可视化的方式，表达系统如何满足所收集的业务规则以及特定的用户需求等信息；
        序列图(The Swquence Diagram)，用于按照交互发生的一系列吮吸，显示对象之间的这些交互；
        类图(The Class Diagram)，业务逻辑和说有支持结构一同被用于定义全部的代码结构；
```



# 7 垃圾回收机制